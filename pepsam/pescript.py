# -*- coding: utf-8 -*-
import base64
import time
from bson import ObjectId

import quantities as pq
import numpy as np

from sage.symbolic.expression import Expression as sage_expr
from sage.rings.integer import Integer as sage_int
from sage.rings.real_mpfr import RealNumber as sage_float

from .mongo_connection import scriptTable 
from .mongo_connection import mongoConnection as mc 
from .expr_set import Expr_set, E, _expr_set_from_dict, ESET_KEY
from .utils import _quantity_to_dict, _quantity_from_dict,\
            _expression_to_dict, _expression_from_dict, test_ipython
from sage.repl.preparse import preparse as preparse_file

from io import StringIO
import os,sys

class dualStdout(StringIO):
    def __init__(self,buf='',old_stdout=sys.__stdout__):
        self.main_stdout=old_stdout
        StringIO.__init__(self,buf)
    
    def write(self,s):
        self.main_stdout.write(s)
        StringIO.write(self,s)

class peScript(object):
    MAX_FILESIZE_BYTES=1024*1024*5
    
    def __init__(self,desc=None,oid=None,keywords=None,code=''):
        if oid is None or oid=='':
            if keywords is None:
                keywords=[]
            self._init_create_from_code(desc=desc,code=code,keywords=keywords)
            oid=self.db()
            print ('new script created in db, with ObjectID: "{}"'.format(str(oid)))
            print ('Paste this ObjectID as the second argument of peScript(..)')
        else:    
            self._init_load_from_db(oid)
            self.update(desc=desc,keywords=keywords)
            
    def eval(self,code,globals,locals={}):
        '''
        The eval function is called when one types %peScript(name,oid),
        right after __init__
        '''
        self.update(code=code)
        self.save_files()
        return self.output         
        
    def _init_create_from_code(self,desc=None,code='',keywords=[]):
        if desc is None:
            raise ValueError('script description cannot be None')
        self.code=code
        self.desc=desc
        self.keywords=keywords
        self.modification_time = time.time()
        self.calculation_time=None
        self.result=dict()  # a dict like {name:value} of a result generated by script
        self.file_set=dict() # name -> binary content, both base64 encoded
        self.output=''
    
    def _init_load_from_db(self,oid):
        if isinstance (oid,str):
            oid=ObjectId(oid)
        dict_=scriptTable.find_one({"_id": oid})
        if dict_==None:
            raise ValueError('cannot find OID ' + repr(oid)+ ' in DB')
        self._load_from_dict(dict_)  
        
    def _load_from_dict(self,dict_):
        '''
Converts a dictionary (manually created or loaded from DB) into a valid peScript instance
'''   
        # convert result
        for key,value in dict_['result'].items():
             if isinstance(value,dict):
                if 'value' in value :
                    if 'units' in value :
                        dict_['result'][key]=_quantity_from_dict(value)
                    else:
                        dict_['result'][key]=np.array(value['value'])
                elif value.has_key('expression') and value.has_key('arguments'):
                    dict_['result'][key]=_expression_from_dict(value)
                elif value.has_key(ESET_KEY):
                    dict_['result'][key]=_expr_set_from_dict(value)
             elif isinstance(value,tuple):
                dict_['result'][key]=list(value) # in db only lists supported
             else:
                dict_['result'][key]=value
        #decode file set
        decoded_fileset={}
        for key,value in dict_['file_set'].items():
            decoded_fileset[base64.b64decode(key)]=base64.b64decode(value)
        dict_['file_set']=decoded_fileset
        self.__dict__=dict_
        
    def dict(self):
        '''
        Serialize self to a plain dict, possibly store-able in mongoDB 
        '''
        encoded_fileset={}
        for key,value in self.file_set.items():
            encoded_fileset[base64.b64encode(key)]=base64.b64encode(value)
        filled_later=['result','file_set']
        adict=dict([(key,value) if key not in filled_later else (key,{}) for key,value in self.__dict__.items()])
        #adict=dict(code=self.code,
        #        desc=self.desc,
        #        keywords=self.keywords,
        #        modification_time=self.modification_time,
        #        calculation_time=self.calculation_time,
       #         result={}, # filled later
        #        file_set=encoded_fileset,
        #        output=self.output,
        #        )
        adict['file_set']=encoded_fileset
        # only result can contain non-strings stuff
        for key,value in self.result.items():
            if isinstance (value,pq.quantity.Quantity):
                adict['result'][key]=_quantity_to_dict(value)
            elif isinstance (value,sage_expr):
                adict['result'][key]=_expression_to_dict(value)
            elif isinstance(value,np.ndarray):
                if value.dtype!=np.dtype('object'):
                    adict['result'][key]={'value':value.tolist()}
            elif isinstance (value,Expr_set):
                adict['result'][key]=value.to_dict() 
            elif isinstance(value,sage_int):
                adict['result'][key]=_quantity_to_dict(pq.Quantity(np.int(value)))
            elif isinstance(value,sage_float):    
                adict['result'][key]=_quantity_to_dict(pq.Quantity(np.float(value)))
            else:
                adict[key]=value
        return adict
               
    def db(self):
        if hasattr(self,'_id'):
            raise RuntimeError('was already saved under OID '+repr (self['_id'])+'. Use peScript.update instead')
        # check if we are not inserting the existing thing
        data_to_insert=self.dict()
        existing_things=scriptTable.find(dict(desc=data_to_insert['desc'])).sort('_id',-1)
        if existing_things.count()==0:
            oid = scriptTable.insert_one(data_to_insert).inserted_id
            #with mc.start_request():
             #   oid=scriptTable.insert(data_to_insert)
            self._id=oid
            return self._id        
        else:
            raise RuntimeError(
                repr(existing_things.count())+
                ' script(s) with exactly the same description already exist (last created oid: ' 
                + repr(existing_things[0]['_id']) + 
                '). If you want to update it, please specify OID in constructor'
            )
 
    def _update_locally(self,code=None,desc=None,keywords=None):
        if desc is not None:
            self.desc=desc#.decode('utf-8')
            return True
        if keywords is not None:
            self.keywords=keywords#[kwd.decode('utf-8') for kwd in keywords]
            return True
        if code is not None:   
            self.code=code#.decode('utf-8')
            self.modification_time = time.time()
            return True
        return False
                   
     
    def update(self,code=None,desc=None,keywords=None):
        need_save=self._update_locally(code=code,desc=desc,keywords=keywords)
        if code is not None:
            self.execute()
        if need_save:
            scriptTable.save(self.dict())
        
    def is_uptodate(self):
        return self.modification_time < self.calculation_time
        
    def execute(self):
        if self.calculation_time is not None:
            if self.is_uptodate():
                return
        
        from tempfile import mkdtemp
        from shutil import rmtree
        oldwkdir=os.getcwd()
        old_stdout = sys.stdout
        
        if (test_ipython()):
            out=dualStdout(old_stdout=old_stdout)
        else:
            out=StringIO()
        
        wkdir=mkdtemp(suffix='pe')
        os.chdir(wkdir)
        codedir=os.path.join(wkdir,'.code')
        os.mkdir(codedir)
        code_filename=os.path.join(codedir,'_code.py')
        with open (code_filename,'w') as f:
            f.write('# -*- coding: utf-8 -*-\nfrom sage.all import *\nfrom pemongo import *\n'
                    +preparse_file(self.code))                                        
        self.file_set={} 
        sys.stdout=out
        
        # import the code and collect results, finally cleanup  
        try: 
            mod=None
            # import the code module into mod and maybe collect exception
            try: 
                mod=import_(code_filename)
            except Exception as e:
                from traceback import format_exc
                print ('Exception:{}\r\n'.format(e))
                print (format_exc() + '\r\n')
                
            # collect result, if applicable    
            try: 
                self.result=dict(mod.result)
            except AttributeError: 
                self.result={}
                
            # collect files     
            onlyfiles = [ f for f in os.listdir(wkdir) if os.path.isfile(os.path.join(wkdir,f)) ] 
            for i,filename in enumerate(onlyfiles): 
                if os.path.getsize(os.path.join(wkdir,filename))>self.MAX_FILESIZE_BYTES:
                    raise RuntimeException('Too big file ' + filename  )
                else:
                # the following is bad for large files. We however set a limit.
                    with open(os.path.join(wkdir,filename),'rb') as f:
                        self.file_set[filename]=f.read()
        # cleanup
        finally: 
            os.chdir(oldwkdir)
            sys.stdout = old_stdout                    
            rmtree(wkdir)
        # collect stdout    
        self.output=out.getvalue()#.decode('utf-8')         
        self.calculation_time=time.time()
        
        
    def save_files(self,dir='.'):
        for filename in self.file_set.keys(): 
            with open (os.path.join(dir,filename),'wb') as f:
                f.write(self.file_set[filename])
        
        
   
import imp, os.path, sys

def import_(filename):
    path, name = os.path.split(filename)
    name, ext = os.path.splitext(name)
    #print ('Before: %s in sys.modules ==' % name, name in sys.modules)
    file_, filename, data = imp.find_module(name, [path])
    mod = imp.load_module(name, file_, filename, data)
    #print ('After: %s in sys.modules ==' % name, name in sys.modules)
    return mod 
          
def remove_if_exists(filename):
    try:
        os.remove(filename)
    except OSError:
        pass

class peScriptRef(dict):
    def __init__(self,oid,name=None):
        dict.__init__(self,oid=ObjectId(oid),name=str(name))
    def __getattr__(self,name):
        if name=='value': # by this trick, the value is retrieved only on demand.
            self.value=peScript(oid=self.oid).result[self.name]
            return self.value 
        return self[name]
   
            
        
         
